## Scope

**정의**: Bean이 존재할 수 있는 **범위**이자 **생명주기**

**스프링 스코프**

1. **기본 스코프**: `Singleton`  `Prototype`
2. **웹 스코프(Web-aware Context)**: `Request`  `Seesion`  `Application`  `WebSocket`

<br>

### 1) 기본 스코프

- 스프링 컨테이너라면 무조건 쓸 수 있는 스코프

<br>

**① 싱글톤(Singleton) - Default**

**정의**: 스프링 컨테이너 하나당 **1개의 객체 인스턴스만** 생성하고 관리

**역할:** `Service`  `Repository`  `Controller` 등 공유해도 안전한 대부분의 Bean에서 사용 

**특징**

- 스프링의 기본값
- 몇 번을 호출해도 항상 같은 객체를 줌
- **상태를 가지면 안 됨(Stateless)** → 여러 클라이언트가 하나의 객체를 공유하기 때문에

 <br>

**② 프로토타입(Prototype)**

**정의**: Bean을 요청할 때마다 **매번 새로운 객체**를 생성하여 반환   

**역할:** 상태를 가지고 있어야 하는 객체나, 사용할 때마다 다른 인스턴스를 생성하고 싶은 경우 사용

**특징**

- 스프링은 객체를 생성하고, 의존성 주입하고, 초기화까지만 해주고 손을 뗌
- `@PreDestroy` 호출 안 됨

<br>

### 2) 웹 스코프(Web-aware ApplicationContext에서만 사용)

- Web-aware ApplicationContext에서만 사용 가능

<br>

**① Request**

**정의**: **HTTP 요청 하나**가 들어오고 나갈 때까지만 유지되는 스코프

**역할**: 해당 요청에서만 필요한 정보 저장 (e.g. 로그인 로그 남기기 등) ****

**특징**

- 요청마다 서로 다른 객체 사용
- 응답을 보내면 객체는 사라짐

<br>

**② Session**

**정의**: **HTTP 세션** 하나와 생명주기가 같음

**역할**: e.g. 로그인 사용자 정보, 장바구니 정보 등

**특징**

- 사용자가 로그인해서 로그아웃할 때까지 객체가 살아있음
- 브라우저를 껐다 켜기 전까지 유지

 <br>

**③ Application**

**정의**: **ServletContext**와 생명주기가 같음

**역할**: e.g. 전역 설정 정보 등

**특징**

- ServletContext(웹 앱 전체) 당 1개

<br>

**④ WebSocket**

**정의**: **WebSocket**과 생명주기가 같음

**역할**: 계속 연결된 상태에서 사용자별 상태를 관리할 때 사용 (e.g. 실시간 채팅방, 푸시 알림 등)

**특징**

- 한 번 연결되면 양방향으로 계속 연결이 유지됨. 이 **연결이 유지되는 동안** 살아있는 빈

<br><br>

## @Scope

---

**정의**: scope를 설정하는 어노테이션

 

**사용법**: `@Component`나 `@Bean`에 붙여서 사용

```java
// `@Scope` 사용 예시
@Component
@Scope("prototype") // 혹은 @Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class MyBean {...}
```

**주의점**

- `request`나 `session` 스코프 Bean을 싱글톤 Bean에 주입할 때, **proxyMode**를 사용해야 함
    
    → 싱글톤은 앱 시작 시 생성되는데, `request`나 `session`은 아직 요청이 없어 생성이 불가능하기 때문에
    
    - **proxyMode**를 사용하면, **가짜 객체(Proxy)**를 먼저 주입해두고, 요청이 들어오면 진짜를 연결해줌

```java
// `proxyMode` 사용 예시
@Scope(value = "request", proxyMode = ScopeProxyMode.TARGET_CLASS)
```

<br>

## Java Singleton(GoF) vs Spring Singleton


### 1) Java Singleton(GoF)

**정의**: **JVM** 전체에서 해당 클래스의 인스턴스가 오직 하나만 생성되도록 하는 패턴

 

**특징**

- JVM 안에서 절대적으로 1개임을 보장
- **테스트 어려움**: 생성자가 `private`이라서 자식 클래스를 만들거나, Mock 객체로 대체하기 어려움

<br>

### 2) Spring Singleton

**정의**: 스프링 컨테이너 안에서 해당 Bean의 인스턴스가 오직 하나만 생성되도록 하는 방식

**특징**

- 만약 JVM 안에서 `AnnotationConfigApplicationContext`를 2개 만들었다면
    - 컨테이너 A, B 각각 `SpringBean`이 1개씩 생김
    - JVM 전체로 보면 2개의 `SpringBean`이 생김
    
      ⇒ 컨테이너 2개를 사용할 일은 없다 봐도 됨
    
- **테스트 용이**