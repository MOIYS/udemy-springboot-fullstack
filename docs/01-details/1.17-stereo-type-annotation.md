## 스테레오타입(Stereotype) 어노테이션


**정의**: 아키텍처 상(개념적 수준)에서 타입 또는 메서드의 역할을 나타내는 어노테이션

**특징**

- `@Controller`, `@Service`, `@Repository`는 모두 내부적으로 `@Component`를 포함하고 있음
- **관심사 분리(Separation of Concerns)** 원칙에 따라, 각 클래스가 어떤 계층에 속하는지 명확하게 구분함
- **AOP 포인트컷  대상**: 특정 계층에 트랜잭션이나 로깅 같은 **횡단 관심사**를 적용할 때, **해당 어노테이션을 기준으로 타겟을 식별**함

<br>

## 스테레오타입 어노테이션 종류


### **1) @Component**

- [@Component](./1.07-component.md#component)

### 2) @Controller

**정의**: 컨트롤러 역할을 하는 클래스에 사용

### 3) @Service

**정의**: 비즈니스 로직을 수행하는 클래스에 사용

### 4) @Repository

**정의**: DB에 접근하는 DAO 역할을 하는 클래스에 사용

<br>

## MVC


**정의**: Model, View, Controller로 나누는 디자인 패턴

### 1) M(Model)

**정의**: 데이터 및 데이터 가공을 책임지는 컴포넌트

**특징**

- 사용자가 편집하길 원하는 모든 데이터를 가지고 있어야 함
- View나 Controller에 대해 어떤 정보도 알면 안 됨
- 변경 발생 시, 변경 통지에 대한 처리 방법을 구현해야 함

 

### 2) V(View)

**정의**: 사용자 인터페이스 요소, 입출력 담당하는 컴포넌트

**특징**

- Model이 가지고 있는 정보를 따로 저장하면 안 됨
- Controller에 대해 어떤 정보도 알면 안 됨
- 변경이 일어나면 변경 통지에 대한 처리 방법을 구현해야 함

### 3) C(Controller)

**정의**: 데이터와 UI를 잇는 처리 역할

**특징**

- Model이나 View에 대해 알고 있어야 함
- Model이나 View를 업데이트하는 로직 포함

<br>

## 구체적인 어노테이션을 사용해야하는 이유


### 1) 의도한 바를 명확하게 나타낼 수 있음(가독성)

- `@Service`를 사용하면 비즈니스 로직, `@Repository`를 사용하면 DB랑 통신하는 클래스라는 걸 쉽게 알 수 있음

### 2) AOP를 사용하여 어노테이션 감지 및 부가적인 동작 가능

- AOP 설정 시, 특정 계층에만 적용할 수 있음

<br>

## AOP(Aspect-Oriented Programming)


**정의**: 비즈니스 로직(Core Concerns)으로부터 부가적인 기능(Cross-Cutting Concerns)을 분리하여 모듈화하는 프로그래밍 패러다임

### **관심사(Concern)**

1. **핵심 관심사(Core Concerns)**
    - 비즈니스 로직
    - e.g. 계좌 이체, 상품 주문 로직 등
2. **횡단 관심사(Cross-Cutting Concerns)**
    - 여러 모듈에 공통적으로 나타나는 부가 기능
    - e.g. 로깅(Logging), 보안(Security), 트랜잭션(Transaction), 성능 측정 등

### AOP 주요 개념

- **Aspect**: 횡단 관심사를 모듈화한 것
- **Advice**: 특정 시점에 실행되는 구체적인 로직. 부가 기능 그 자체
    - e.g. 실행 전, 실행 후, 예외 발생 시 등
- **Pointcut**: 조인포인트 중, 실제로 어드바이스를 적용할 대상을 선별하는 표현식
- **JoinPoint**: 어드바이스가 적용될 수 있는 실행 시점
- **Target**: 어드바이스를 적용 받는 실제 객체

### Spring AOP 특징

1. **프록시 기반**
    - target 객체를 감싸는 프록시를 런타임에 생성하여 advice 수행
    - 호출자가 메서드를 호출하면 프록시가 먼저 가로채서 advice를 실행하고, 실제 target의 
    메서드 호출
2. **비침투적(Non-Invasive)**
    - 핵심 비즈니스 로직 코드에는 AOP 관련 코드가 없음
3. **메서드 레벨 지원**
    - 스프링 AOP는 메서드 실행 시점에만 AOP 적용 가능
        - **이유**: 프록시는 메서드 호출만 가로챌 수 있기 때문에

### Spring AOP **주의할 점**

1. **내부 호출(Self-Invocation) 문제**
    - **상황**: 클래스 내부 메서드(`methodA`)가 같은 클래스의 다른 메서드(`methodB`)를 호출할 때
    - **문제점**: `this.methodB()` 형태로 호출하는데, 해당 `this`는 프록시가 아닌 **실제 target** 
    → (프록시를 거치지 않고, 바로 메서드가 호출되므로) **AOP가 적용되지 않음**
    - **해결책**: 다른 객체로 분리하거나, `AopContext` 등 사용
2. **Private 메서드적용 불가**
    - 프록시가 target 메서드를 호출하거나 상속받는 구조이기 때문에
3. **디버깅 어려움**
    - 런타임에 프록시가 개입하기 때문에, 에러 발생 시 디버깅이 까다로움
4. **성능 오버헤드**
    - 메서드 호출마다 프록시를 거쳐야해서 오버헤드 발생 가능