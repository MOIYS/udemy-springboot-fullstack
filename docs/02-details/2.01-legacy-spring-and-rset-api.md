# Spring Boot가 없던 시절 (Legacy Spring) 애플리케이션 빌드

### 1) 의존성 관리의 어려움(pom.xml)

- `pom.xml`에 라이브러리 버전을 하나하나 다 적어야 했음
    - **문제점**: 서로 호환되는 버전을 개발자가 일일이 확인하고 사용해야 함
    - **Spring Boot의 경우**: `Starter`로 해당 의존성들을 맞춰줌

<br>

### 2) web.xml

**정의**: Java 웹 애플리케이션의 배포 설명자(deployment descriptor) 파일. 해당 파일을 통해 서버가 애플리케이션을 어떻게 구성하고 연결할지 알려줌

<br>

**문제점** 

- **복잡함**
- 오타가 발생할 경우, **컴파일 체크 불가**

<br>

**Spring Boot의 경우**

- `web.xml`을 사용하지 않음
- boot  실행 시, `DispatcherServlet` 자동 등록
- 어떤 url로 들어오든, 스프링이 처리
- 필터 설정도 XML 대신 `@Component`나 `FilterRegistrationBean`으로 처리

<br>

### 3) Spring 설정 (context.xml)

**정의**: Bean 생성 및 조립 설명서. Bean 등록, DB 연결 설정 등의 기능 보유

<br>

**문제점**

- **가독성 안 좋음**
    - 로직은 자바 파일, 설정은 XML 파일
- **유지보수 어려움**
    - 클래스명을 바꾸면, XML 파일에서도 수동으로 수정해야 함

<br>

**Spring Boot의 경우**

- Java Config(어노테이션)이 표준
    - `@Configuration`
    - `@Bean`
    - `@SpringBootApplication`
    - `@Component`
    - `@Autowired` 등

<br>

### 4) NFRs (Non-Functional Requirements, 비기능적 요구사항)

**Spring Boot 사용 이점**

- 내장 서버, Actuator, 로그 설정, 보안 등을 통해 NFR을 **‘Out-of-the-box(설정 없이 사용 가능한)’ 상태로** 제공

<br>
<br>

# REST API


**정의**: REST(REpresentational State Transfer) 아키텍처 스타일 설계 원칙을 따르는 API

<br>

- **REST 동작 원리**
    
    1\. 주소(URI)로 자원(resource)을 명시
    
    2\. HTTP 메서드로 행위를 결정 (`GET`, `POST`, `PUT`, `DELETE` 등)
    
    3\. 자원의 형태를 주고받음 (JSON, XML, Text 등)

<br>

### 1) @RestController

**정의**: `@Controller` + `@ResponseBody`를 합친 것

- **역할**: JSON 형태로 객체 데이터를 반환하는 것

<br>

### 2) @RequestMapping

**정의**: 요청 들어온 URL을 어떤 메서드가 처리할지 매핑해주는 것

<br>

**사용 위치**

- **클래스 위**: 공통된 URL 경로를 처리할 때 사용
- **메서드 위**: 구체적인 경로 및 HTTP 메서드 지정 (`@GetMapping`, `@PostMapping` 등을 더 많이 사용)

```java
// @RestController & @RequestMapping 사용 예시

@RestController
@RequestMapping("/api/users")  // 해당 클래스는 '/api/users/'로 시작하는 주소 처리
public class UserRestController {
	@GetMapping
	public String getAllUsers() {
		return "Get All Users";
	}
}
```