# JPA

## JPA(Java Persistence API)란?

**정의**: 자바 **ORM(Object-Relational Mapping) 기술 표준**. 자바 객체와 DB 테이블을 자동으로 연결해 주는 인터페이스

- **인터페이스**: JPA는 인터페이스고, 구현체는 주로 **Hibernate** 사용
- **ORM**: 객체와 RDBM 테이블을 자동으로 연결시켜주는 기술

<br>

**특징**

- **SQL 의존성 제거**: SQL을 직접 짜지 않고, 자바 코드로 메서드를 호출하면 JPA가 알맞은 SQL을 생성해서 실행.
- **패러다임 불일치 해결**: 객체지향과 RDBMS 간의 개념 차이를 해결해 줌.
- **변경 감지(Dirty Checking)**: 객체의 값을 수정 하면, 커밋 시점에 알아서 `UPDATE` 쿼리 실행.
- **생산성 향상**

<br>

**단점**

- **러닝 커브**: 객체와 RDBMS 둘 다 이해해야 함.
- **복잡한 쿼리 처리**: 통계나 복잡한 조인의 경우 JPA만으로 처리하기 어려움. (QueryDSL이나 Native SQL을 함께 사용)
- **N+1 문제**: 데이터를 조회할 때, 연관된 데이터 때문에 쿼리가 N번 더 실행되는 문제
    - **해결법**: Fetch Join

<br>
<br>

## JPA 핵심 어노테이션

### 1. @Entity

- **의미**: DB 테이블과 1:1로 매핑되는 클래스
- **특징**
    - JPA가 관리하기 위해서는 해당 어노테이션이 필수.
    - **기본 생성자**가 있어야 함.

<br>

### 2. @Id

- **의미**: 해당 필드가 테이블의 PK임을 나타냄
- **특징**
    - 필드명과 컬럼명이 같으면 생략 가능
    - 제약조건을 걸 때 사용 (e.g. `nullable=false`)

<br>

### 3. @Column

- **의미**: 해당 필드가 DB의 특정 컬럼과 연결됨을 나타냄
- **특징**
    - 필드명과 컬럼명이 같으면 생략 가능
    - 제약조건을 걸 때 사용 (e.g. `nullable=false`)

<br>
<br>

## EntityManager와 @PersistenceContext

### EntityManager

- **정의**: 엔티티 저장, 조회, 삭제, 수정 등의 작업 담당 인터페이스

<br>

### @PersistenceContext

- **의미**: `EntityManager`를 주입받을 때 사용하는 어노테이션

- **작동 원리**
    - `EntityManager`에 프록시 객체 주입
        - → 스프링 빈은 싱글톤이라 1개 존재. 모든 스레드가 해당 프록시 사용
        - ⇒ 그러나 트랜잭션을 시작하면, 해당 스레드 전용 진짜 `EntityManager`를 만들어서 사용하게 함.

<br>

**프록시 객체 사용 이유**
- 프록시 객체를 사용하지 않으면, 모든 스레드가 1개의 `EntityManager` 사용
    - → 여러 스레드가 동시에 `EntityManager`를 사용할 경우, 덮어쓰여지거나 사용하는 중에 트랜잭션이 닫히거나 하는 문제 발생 가능

<br>
<br>

## @Transactional

- **의미**: 메서드나 클래스에 트랜잭션을 적용하는 어노테이션

<br>

### TransactionRequiredException 에러 발생

- **에러 내용**
    - `Caused by: jakarta.persistence.TransactionRequiredException: No EntityManager with actual transaction available for current thread - cannot reliably process 'merge' call`

<br>

- **발생 원인**
    - JPA는 **데이터를 변경(삽입, 수정, 삭제)**하는 모든 작업을 **트랜잭션 안에서 수행**해야 하는 원칙이 있음
        - **이유**: 트랜잭션 작업 중, 에러가 발생하면 롤백할 수 있게

<br>
<br>

## JPA와 Hibernate 차이점

- JPA는 인터페이스이고, Hibernate는 JPA 인터페이스를 구현한 구현체

<br>

**작동 흐름**

1\. `jakarta.persistence.*` (JPA표준 인터페이스)를 import 해서 코드 작성 

2\. 프로젝트 시작 시, Spring Boot가 JPA 구현체로 Hibernate 라이브러리를 감지하고, 자동 연결

3\. 실행 시점에 `jakarta.persistence` 코드가 실행되면, 실제로는 Hibernate가 동작 수행  

<br>
<br>
<br>

# Spring Data JPA


**정의**: 스프링 프레임워크가 JPA(Hibernate)를 더 쉽게 사용할 수 있도록 만든 라이브러리

<br>

**특징**

- **구현 클래스가 필요 없음**
    - 인터페이스 선언하고, `JpaRepository` 상속받으면 됨

- **기본 CRUD 메서드 자동 제공**
    - `save()` (저장/수정)
    - `findById()` (조회)
    - `findAll()` (전체 조회)
    - `delete()` (삭제)

- **메서드 이름으로 쿼리 생성**
    - 명명 규칙에 맞게 메서드 이름을 지으면, 스프링이 자동으로 쿼리를 짜줌.

- **페이징과 정렬 자동화**