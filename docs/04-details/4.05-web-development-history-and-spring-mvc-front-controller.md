## 웹 애플리케이션 개발 역사

### 모델1 아키텍처

**구조**: 브라우저 요청을 JSP가 직접 받음

**특징**

- Java 웹 앱 개발 가장 초기에는 jsp에 모든 코드(HTML, Java, SQL)를 담았음

**장점**

- 개발 속도가 빠름 (파일 1개에 다 넣어서)

**단점**

- **스파게티 코드**
- **유지보수 불가**
- **재사용 불가**

<br>
<br>

### 모델2 아키텍처

**구조**: MVC 패턴

- **controller(Servlet)**: 요청을 받아서 비즈니스 로직 처리
- **model(Java Bean)**: 처리된 결과 데이터를 담음
- **view(JSP)**: 데이터를 받아서 화면 출력

**장점**

- 화면과 로직이 분리되어 유지보수가 좋음

**단점**

- **서블릿이 많아짐**
- **중복 코드**: 서블릿마다 로직 중복

<br>
<br>

### 모델2 아키텍처 - front controller

**구조** 

- 모든 요청이 **FrontController**로 감
    - 중앙 컨트롤러 개념
- 해당 요청을 컨트롤러나 서블릿 또는 뷰로 전달

**장점**

- 깔끔한 구조

<br>
<br>

### Spring MVC Front Controller - Dispatcher Servlet

- 스프링 프레임워크는 FrontController 패턴을 구현한 `DispatcherServlet` 제공

<br>

**동작 흐름**

1. **HTTP Request 수신**
- 클라이언트가 `/{end-point}`로 접속
- `DispatcherServlet`이 해당 요청을 가로챔

2. **컨트롤러 조회 (Handler Mapping)**
- `DispatcherServlet`이 해당 URL을 누가 처리하는지 `HandlerMapping`에게 물어봄 → 어떤 메서드가 처리하는지 확인

3. **Adapter 조회** (`HandlerAdapter`): 해당 컨트롤러 실행을 대행할 `HandlerAdapter`를 찾음

4. **Argument Resolution** (`HandlerMethodArgumentResolver`)
- `HandlerAdapter`가 메서드를 실행하기 위해 필요한 파라미터 확인
- 등록된 모든 `Resolver`들을 순회하며, `supportsParameter()` 호출
- 파라미터를 처리할 수 있는 `Resolver`가 처리할 수 있다고 응답하고 객체 반환

5. **Method Invocation (Reflection)**
- 모든 파라미터가 준비되면,  `HandlerAdapter`가 리플렉션 기술(`method.invoke()`)을 사용하여 메서드 실행

6. **Return Value Handling**: `RetrunValueHandler`가 리턴값을 View나 JSON으로 변환
- (리턴값이 View 이름이면) `ViewResolver`가 JSP 파일을 찾음
- (`@ResponseBody`면) JSON 변환 후 끝

7. **View 실행 및 Response 반환**
- HTML 렌더링 후 응답